# Results {#results}
<!--
This chunk was necessary when using python for some models, however it is probably no longer necessary
```{r setup2, include=FALSE}
knitr::opts_chunk$set(echo=TRUE, engine.path = list(python = '/anaconda/bin/python'))
```
-->

```{r loadSummaryStats}
DFsummary <- readRDS(paste0(dFolder, "allModelSummaryStats.rds"))
dfSummary <- readRDS(paste0(dFolder, "allHouseModelStats.rds"))
```
This chapter uses a selection of models fitted to our half hour averaged data in order to forecast the demand of the following half hour.

## Naive model

In our naive model we assume no drift, and only attempt to predict one (half hour) time step onto the future. From Equation \@ref(eq:randomWalk), we get 
\begin{equation}
\hat x_{t+1} = x_t .
\end{equation}

```{r randomWalk, out.width='100%', fig.cap="Actual electricity use and naive model approximation over one day for four households"}
knitr::include_graphics(paste0(pFolder, "randomWalk/fourHouses.pdf"))
```

As can be seen in Figure \@ref(fig:randomWalk), this method is reasonably effective for some houses, in particular those that have long periods where the element power has roughly the same output. In contrast, households that exhibit frequent oscillation of element power are very poorly modelled by this method, with the predicted values consistantly 'missing' the actual values.

The random walk model has RMSE ranging between between `r min(dfSummary$RMSE[dfSummary$model == "naive"])`W and `r max(dfSummary$RMSE[dfSummary$model == "naive"])`W, with the average being `r DFsummary$RMSE[DFsummary$model == "naive"]`W.

The model precisely mimics the actual data with a half-hour lag, and therefore scores highly for physical fidelity. Interpretability is high as this model is represented by a very simple equation, although no illumination as to underlying behavioural properties are provided by this model. The computational time to fit models to each household varied between `r min(dfSummary$fittingTime[dfSummary$model == "naive"])`s and `r max(dfSummary$fittingTime[dfSummary$model == "naive"])`s, with the average taking `r DFsummary$fittingTime[DFsummary$model == "naive"]`s.

## Linear regression of hot water electricity against lagged other electricity

While simple linear regression is a useful method of analysing data that has a roughly linear trend, it is generally inadequate when constructed using time series data that displays cyclic behaviour, such as residential electricity demand.
Where it may be useful, however, is in predicting the relationship between hot water electricity demand and non hot water electricity demand.
The significance of the cross-correlogram (Fig. \@ref(fig:crossCovariance)) in the initial positive lags suggests we may be able to construct a simple linear model which forecasts hot water electricity use based on the previous half-hour's non hot water electricity use.

```{r linearRelations, out.width='100%', fig.cap="Linear relation between non hot water electricity and half-hour lagged hot water electricity for household rf06"}
knitr::include_graphics(paste0(pFolder, "rf06LinearPlot.pdf"))
```

Figure \@ref(fig:linearRelations) shows a simple linear regression of current non hot water electricity demand with the following half-hour's hot water electricity demand. This is shown to demonstrate the ability to use current electricity demand to predict hot water electricity demand over the next half hour. Note the low $R^2$ value suggesting that, in it's current form, this model would be rather inadequate at forecasting demand.

```{r simpleLinear, out.width='100%', fig.cap="Performance of simple linear regression model for four households over four separate days"}
knitr::include_graphics(paste0(pFolder, "simpleLinear/fourHouses.pdf"))
```
Figure \@ref(fig:simpleLinear) shows the effectiveness of this model for four seperate households. Note that the top two households in the figure, `rf_13` and `rf_30`, show the model fitting reasonable poorly with the data. 
Household `rf_13` appears to predict increase in hot water electricity demand before it actually occurs. 
This should be compared to Figure \@ref(fig:crossCovariance), which shows the correllation between hot water and not hot water electricity peaking at around 200 minutes lag for this household.
Household `rf_30` shows a model which appears to be very unresponsive to the data. Again, on close examination of Figure \@ref(fig:crossCovariance) we see that this household has a peak in crosscorrelation at around 800 minutes. 
This indicates that for some households, a correlation lag of greater than 30 mins may increase accuracy. 
Households `rf_42` and `rf_44` show a more accurate model result, however due to the presence of a non-zero y intercept these models will always consistantly overestimate hot water electricity whenever the true value is zero.

The simple linear regression model has RMSE ranging between between `r round(min(dfSummary$RMSE[dfSummary$model == "simpleLinear"]), 2)`W and `r round(max(dfSummary$RMSE[dfSummary$model == "simpleLinear"]), 2)`W, with the average being `r round(DFsummary$RMSE[DFsummary$model == "simpleLinear"], 2)`W.

The model does not accurately capture zero values, and is significantly smoother than the actual data, however no negative values are present. It therefore scores low to moderate for physical fidelity. 
Interpretability is high, as the output can be understood by the simple equation $\hat x_{t+1} = \alpha_0 + \alpha_1 w_t$, where $w_t$ is non hot water electricity at time $t$.  The computational time to fit models to each household varied between `r round(min(dfSummary$fittingTime[dfSummary$model == "simpleLinear"]), 2)`s and `r round(max(dfSummary$fittingTime[dfSummary$model == "simpleLinear"]), 2)`s, with the average taking `r round(DFsummary$fittingTime[DFsummary$model == "simpleLinear"], 2)`s.

Notably, this model has lower RMSE's than the Naive model.
In addition, this model lends itself to being utilised as an input into more complex models that take other parameters into consideration. 

## ARIMA model

As each household has different usage patterns and characteristics, optimal values for these parameters differ for each household.
The optimal parameters for each household which minimise the AIC (refer to Section \@ref(ARIMAmethodology)) are provided in the appendix.

The simple linear regression model has RMSE ranging between between `r round(min(dfSummary$RMSE[dfSummary$model == "ARIMA"]), 2)`W and `r round(max(dfSummary$RMSE[dfSummary$model == "ARIMA"]), 2)`W, with the average being `r round(DFsummary$RMSE[DFsummary$model == "ARIMA"], 2)`W.

The model does not often predict the initial instance of the element turning on, and is somewhat smoother than the actual data. In addition, occasional negative values or values above that capable of the element occur. It scores low to moderate for physical fidelity. 
Interpretability is moderate, as the output can be understood by the value of the $p$, $d$ and $q$ parameters (provided in the appendix). The computational time to fit models to each household varied between `r round(min(dfSummary$fittingTime[dfSummary$model == "ARIMA"]), 2)`s and `r round(max(dfSummary$fittingTime[dfSummary$model == "ARIMA"]), 2)`s, with the average taking `r round(DFsummary$fittingTime[DFsummary$model == "ARIMA"], 2)`s.

```{r ARIMAplot, out.width=100% include = FALSE, fig.cap="Performance of ARIMA model for four households over four separate days"}
knitr::include_graphics(paste0(pFolder, "/ARIMA/fourHouses.pdf"))
```

<!--

```{r frequencyPlot, eval = FALSE, include=FALSE, fig.cap="Frequency of power observations"}
p <- ggplot(dfSimp, aes(x = value, fill = type)) +
  geom_histogram(binwidth = 100) +
  facet_wrap(. ~ type)
p + labs(y = "Observations",
       x = "Power (W)") + # use colour-blind friendly palette
  theme(legend.position = "bottom")
```

Figure \@ref(fig:frequencyPlot) shows the frequency of observations of power (100W bin width) for both the data and the model.
It can be seen that the model does not fit the data accurately in this regard. In part this may be due to regular occurrences of the element only needing to reheat the water slightly due to thermal losses from the wall of the tank, or very minor hot water usage events.


```{r residualACF, eval = FALSE, fig.cap="Autocovariance of the ARIMA model residuals"}
p <- forecast::ggAcf(HWres, lag.max = weekCycle*2, type = "correlation",
    plot = TRUE, na.action = na.pass)
p + labs(x = "Lag", y = "Autocorrelation", title = "")
```

This plot of the autocorrelation function of the residuals (Fig. \@ref(fig:residualACF) shows that autocorrelation of residuals is negligible, however some cyclical behaviour can be observed. In particular, many houses display a weekly peak (at lag `r weekCycle`). This is perhaps due to the weekly cycle not being taken into consideration with all houses.

The absolute value of the residuals is calculated, and the mean of this is taken to demonstrate the error of this model for the individual house selected.

```{r residualsPlot, eval = FALSE}
#hidden for now - doesn't really add anything
plot(HWres, type = "c")
```

<!--
The mean value and standard deviation of the residual is r round(meanHWres, 1) W and  r round(sdRes, 1)  respectively, whereas the mean and standard deviation of the absolute value of the residual is  r round(meanHWresAbs, 1) W and  r round(sdResAbs, 1)  respectively. This suggests that while the VAR model residual at any one time for an individual house may be too large for accurate forecasting, the addition of more houses may significantly reduce this.
-->
_NOTE: work out error as percent of element power?_

To explore this further we examine a dataframe consisting of the residuals of the various houses (see `scripts/VAR_residual_df.R`). 

```{r loadResidualDF, eval = FALSE}
load(file = "~/HWCanalysis/Masters/data/resDF.Rda")
load(file = "~/HWCanalysis/Masters/data/amalgamatedRes.Rda")
```

The mean residual when all r length(unique(resDF$house)) houses are considered together is r round(mean(w[,"HWres"]), 1)W, whereas the mean of the absolute value of all houses considered together is r round(mean(w[, "HWresAbs"]), 1)W.

```{r cyclicalMatrix, eval = FALSE}
#incomplete - an attempt to determine the component of the VAR model responsible for cyclical effects
#cycle <- var1$varresult$HWelec$qr$qr
#plot(cycle)
#acf(cycle)
```
The VAR model provides a reasonably accurate means of forecasting. It is be possible to forecast half an hour in advance using minute data but this may not be practically implimentable in reality (smart meters may not store minute data as such).

